#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp (ql:quickload '(:dirtylogman :cl-csv) :silent t)
  )

(defpackage :ros.script.dirty.3717744938
  (:use :cl :dirtylogman :trivia :iterate :cl-csv))
(in-package :ros.script.dirty.3717744938)

(defun usage ()
  (princ "
Usage: dirty -y rule.yaml [inputfiles...]
"))

(defvar *yaml*)

(defun main (&rest argv)
  (declare (ignorable argv))
  (match argv
    (nil
     (let ((no-input t))
       (iter (for file in-stream *standard-input* using #'read-line)
             (for result = (process (pathname *yaml*) file))
             (when (first-iteration-p)
               (setf no-input nil)
               (cl-csv:write-csv-row (mapcar #'car result) :stream *standard-output*))
             (cl-csv:write-csv-row (mapcar #'cdr result) :stream *standard-output*))
       (when no-input
         (usage))))
    
    ((list* "-y" *yaml* rest)
     (apply #'main rest))

    ((list* "-p" rest)
     ;; debug mode
     (ql:quickload :swank)
     #+nil
     (swank/backend:profile )
     (uiop:symbol-call :swank/backend :profile 'uiop:run-program)
     #+nil
     (swank/backend:profile-package )
     (uiop:symbol-call :swank :profile-package :dirtylogman nil t)
     (unwind-protect
          (time (apply #'main rest))
       (uiop:symbol-call :swank :profile-report)
       (room)))
    
    ((list* rest)
     (iter (for file in rest)
           (for result = (process (pathname *yaml*) file))
           (when (first-iteration-p)
             (cl-csv:write-csv-row (mapcar #'car result) :stream *standard-output*))
           (cl-csv:write-csv-row (mapcar #'cdr result) :stream *standard-output*)))))
;;; vim: set ft=lisp lisp:
